Task 1:
    1.1:
Am inceput prin citirea unui fisier specificat prin parametru. Am verificat daca fisierul exista, iar daca nu, am afisat un mesaj de eroare si am incheiat executia. Structura secretariat a fost initializata, alocand dinamic memorie pentru aceasta. Apoi, am parcurs fisierul linie cu linie pentru a determina numarul de studenti, materii si inrolari, setand aceste valori in structura principala.
Am alocat memorie pentru fiecare categorie (studenti, materii, inrolari) in functie de numarul determinat anterior. Am resetat pozitia fisierului pentru a incepe parcurgerea efectiva a datelor. Am folosit cate un contor pentru fiecare sectiune din fisier: (studenti, materii, inrolari). Am copiat sectiunea pentru a putea tine minte in care dintre cele 3 sunt si am citit conform datelor. Am calculat media generala pentru fiecare student, pe baza notelor din sectiunea de inrolari. Am folosit o matrice alocata dinamic pentru a contoriza numarul de materii pentru fiecare student. Pentru fiecare inrolare, am acumulat suma notelor (cu un factor Power = 10) si am facut media rotunjind doar daca partea zecimala era >= cu 0.50.

    1.2:
La functia adauga_student am folosit realloc pentru a mari dimensiunea vectorului de studenti, am actualizat numarul total de studenti si am completat campurile (ID, nume, an de studiu, statut si medie generala).

    1.3:
Am implementat functia elibereaza_secretariat parcurgand fiecare materie pentru a elibera stringurile alocate dinamic pentru nume si numele titularului. Dupa, am eliberat vectorii de materii, inrolari si studenti. La final, am eliberat structura principala si am setat pointerul la NULL.

s
Task 2:
Aici am implementat 3 functii ajutatoare de baza (proceseaza_interogare, proceseaza_update si proceseaza_delete), si 2 mai mici pentru a evalua comaparatorul, campul si valoarea introduse de la tastatura.

* Functia compara_operator compara o valoare numerica (float) cu un string convertit la float, utilizand operatori precum "=", "<", ">", "<=", ">=", "!=". Daca operatorul e valid, se returneaza 1 daca comparatia e adevarata si 0 in caz contrar. Pentru conversia stringului se foloseste atof, iar verificarea operatorului se face cu strcmp.

* Functia compara_operator_nume compara doua siruri de caractere (char*) folosind operatori lexicografici precum "=", "<", ">", "<=", ">=", "!=". Comparatia e realizata cu strcmp, iar rezultatul e 1 daca conditia e adevarata sau 0 daca e falsa.

*Functia proceseaza_interogare proceseaza comenzi SQL simple asupra unei baze de date simulate. Verifica prezenta cuvintelor cheie precum "AND", "WHERE" sau "FROM" in comanda si extrage campurile, tabelul si conditiile relevante folosind sscanf. In functie de tabelul identificat ("studenti", "materii" sau "inrolari"), aplica filtre pe baza conditiilor specificate si afiseaza campurile cerute. Filtrarea se face prin compararea valorilor campurilor cu operatorii dati, inclusiv pentru conditii complexe cu "AND". De asemenea, trateaza cazurile speciale in care nu exista conditii sau cand toate campurile trebuie afisate. La final, elibereaza memoria alocata dinamic.

*Functia `proceseaza_update face exact ce spune numele: actualizeaza datele din baza de date (sper ca si bine), pe baza unei comenzi de tip SQL `UPDATE`. In primul rand, aloca memorie pentru variabilele care vor tine diferite informatii despre ce trebuie actualizat, adica tabelul, campurile si valorile pe care le primeste comanda. Daca alocarea de memorie nu merge bine, scoate un mesaj de eroare si opreste tot. Apoi, citeste comanda si cauta detaliile in textul comenzii, ca sa stie ce tabel vrea sa modifice, ce campuri si ce valori sa puna acolo. Daca comanda contine "AND" (adica mai multe conditii), le ia si le salveaza pentru a le folosi mai departe. Apoi, in functie de ce camp trebuie modificat, cum ar fi "nume", "note", sau "statut", pregateste valorile pentru fiecare, de exemplu: daca modifica "note", le imparte in trei si le pune in variabile separate. Daca tabelul este "studenti", "materii" sau "inrolari", parcurge fiecare inregistrare si verifica daca indeplineste conditiile date. Daca da, face modificarile pe care le cere comanda, adica schimba valorile din acele inregistrari. Daca sunt modificari la inrolari, se calculeaza din nou media generala a studentilor in functie de notele lor si de cate materii au. La final, se elibereaza toata memoria care a fost alocata pentru variabilele folosite.

*Deci (aici e buba), functia asta primeste o comanda in care vrei sa stergi niste date dintr-o baza de date. In primul rand, se uita daca comanda contine cuvantul DELETE, care e semnalul ca vrei sa stergi ceva. Daca nu gaseste DELETE, iti zice ca ceva e gresit si se opreste acolo. Apoi, daca vede ca in comanda apare AND, intelege ca vrei sa pui si niste conditii suplimentare pentru ce vrei sa stergi. Apoi, aloca niste spatiu in memorie ca sa pastreze datele din comanda (adica ce tabel, ce campuri, ce operatori si valori trebuie sa foloseasca). Daca nu poate sa aloce suficient spatiu, iti zice ca e o eroare si iese din functie. Mai departe, functia incearca sa imparta comanda si sa extraga ce trebuie din ea, cum ar fi numele tabelului, ce campuri vrei sa compari si operatorii pentru comparare. Daca sunt conditii suplimentare (de exemplu, cu AND), se ocupa si de ele, despartind valorile si punandu-le deoparte. Apoi, verifica daca tabelul despre care vorbesti e "studenti", "materii" sau "inrolari". Daca e vreunul din ele, incepe sa parcurga fiecare inregistrare si verifica daca indeplineste conditiile de la tine. Daca gaseste o inregistrare care se potriveste, o sterge. Daca e cazul de conditii suplimentare cu AND, le verifica si pe astea, si daca totul se potriveste, sterge inregistrarea. Dupa ce sterge, daca a fost vorba de tabelul "inrolari", recalculaza media generala a studentilor, ca sa fie corecta dupa ce se fac stergerile. La final, elibereaza toata memoria pe care a alocat-o pentru a nu ramane blocat cu ea. "Buba" este ca atunci cand este o baza mare de date (big.db), cand se sterg studenti, vad ca media lor este "shiftata" cu 1 cat timp e doar 1 sters, cand ajunge la al 2 lea se duce la 2 valori, si tot asa... . Rip test9.in pt big.db...

Main-ul nu e wow: Incep prin a verifica daca am dat un fisier de intrare atunci cand rulez programul (adica un fisier in care se afla baza de date). Daca nu am dat niciun fisier, apare un mesaj de eroare si programul se opreste. Daca fisierul de intrare contine un separator (gen ":") pentru a separa numele fisierului de alte informatii, programul se opreste la acea linie si pastreaza doar numele fisierului. Apoi, incearca sa deschida fisierul de baza de date cu functia `citeste_secretariat`. Daca nu reuseste, zice ca nu a reusit sa citeasca baza de date si programul se opreste. Dupa ce citeste baza de date, urmeaza sa citeasca un numar de comenzi (un intreg care spune de cate ori sa repeta procesul de citire a comenzilor). Daca nu reuseste sa citeasca corect numarul de comenzi, apare o eroare si programul se opreste. Apoi, pentru fiecare comanda, citeste linia si verifica ce tip de comanda este: daca e UPDATE, apeleaza functia care proceseaza update-uri, daca e DELETE apeleaza functia pentru stergerea inregistrarilor, si daca e SELECT cu WHERE sau AND, sau alte comenzi similare, apeleaza functia care se ocupa cu interogarile. Daca gaseste o comanda necunoscuta, zice ce comanda nu a putut sa o recunoasca. La final, elibereaza memoria folosita pentru baza de date si "gata".